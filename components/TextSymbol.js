/**
 * A Symbol consists of either: a set of rules for generating text and/or modifying state, or a piece of text (injected from an outside context or generated by Symbol rules).
 * Each Rule consists of an Expression and some optional metadata about how the Rule should be executed. When a Symbol is evaluated either by another Rule on the same Grammar
 * or by accessing directly, it can either be expanded or flattened.
 * Expanding a Symbol runs its rules and returns the resulting output.
 * Flattening a Symbol runs its rules and replaces the Symbol with its resulting output. The next time the Symbol is accessed, it will return the previously-generated value.
 */
const TextExpression = require('./TextExpression');
module.exports = class TextSymbol {
  /**
   * @param {String|TextExpression|String[]|TextExpression[]|Function} rules - the set of rules this symbol will use to generate its output. Should be either a valid expression or an array of
   * such, or a function that accepts grammar as an (optional) argument and returns a valid expression
   * @param {Object} grammar - the Grammar this symbol belongs to, use to evaluate its rules and their expressions
   * @param {String} [value] - optionally set the initial value for this symbol
   * @param {Object} [config] - config option
   */
  constructor(rules = [], grammar, value, config) {
    this.grammar = grammar;
    this.flatText = value;
    this.flattened = !!value;
    this.initialRules = rules;
    // supported distributions are:
    // random (default) -- all valid rules have an equal chance of being selected
    // pop -- like random but rules are removed as used (no repeats, but can run out!)
    // weighted -- like random but rules have a higher chance of being selected depending on their weight (set in expression config)
    // popWeighted -- like weighted but rules are removed as used
    // shuffle -- rules are treated like a "deck of cards", rules do not repeat until the whole stack is used and then the "discards" are shuffled as a new deck
    this.distribution = config?.distribution || 'random';
    this.setRules(rules);
    this.usedRules = [];
    this.rulesChecked = 0; // avoid rule checker spinning out
  }
  /**
   * If the symbol has already been flattened, return the flatText value, otherwise flatten it and return that result
   * */
  get value() {
    return this.flatText || this.expand(true);
  }
  /** Set the value of the Symbol
   * @param {String|TextExpression} expression - new expression which is evaluated to becomes the new value
   * */
  set value(expression) {
    this.flatText = (
      expression instanceof TextExpression
        ? expression
        : new TextExpression(expression, this.grammar)
    ).evaluate();
    this.flattened = true;
  }
  /** Set or reset the rules for this symbol */
  setRules(rules) {
    this.ruleFunc = null;
    this.rules = [];
    if (typeof rules === 'function') this.ruleFunc = rules;
    if (typeof rules === 'string') this.rules = [rules];
    if (Array.isArray(rules)) this.rules = rules;
    // convert all rules to expressions
    this.rules = this.rules.map((rule) =>
      typeof rule === 'object'
        ? new TextExpression(rule.text, this.grammar, rule)
        : new TextExpression(rule, this.grammar)
    );
    // if using popWeighted, create dummy copies of the rules by weight
    if (this.distribution === 'popWeighted') {
      this.rules.forEach((rule) => {
        let copies = rule.weight || 1;
        for (let i = 1; i < copies; i += 1) {
          this.rules.push(rule);
        }
      });
    }
    // shuffle the rules if needed
    if (['shuffle', 'pop', 'popWeighted'].includes(this.distribution)) {
      this.rules = this.grammar.rng.shuffle(this.rules);
    }
  }
  /** Select a rule to use to expand/flatten the symbol
   * You could override this method to provide a custom rule selection approach.
   */
  selectRule() {
    // if there is rule function, use that
    if (this.ruleFunc) return this.ruleFunc(this.grammar);
    // handle running out of rules
    if (this.rules.length === 0) {
      // if using shuffle, return the discards to the rules
      if (this.distribution === 'shuffle') {
        // TODO: shuffle them
        this.rules = [...this.usedRules];
        this.usedRules = [];
        return this.selectRule();
      }
      return null;
    }
    const usePop = ['shuffle', 'pop', 'popWeighted'].includes(
      this.distribution
    );
    // Start by selecting a random rule, or popping a rule off the stack (depending on distribution)
    const nextRule = usePop
      ? this.rules.pop()
      : this.grammar.rng[
          this.distribution === 'weighted' ? 'pickFromWeighted' : 'pickFrom'
        ](this.rules);
    this.rulesChecked += 1;
    // skip any rule that evaluates falsey
    if (nextRule && nextRule.evaluate()) {
      // if using pop/shuffle put this on the "discard"
      if (usePop) this.usedRules.push(nextRule);
      // reset counter
      this.rulesChecked = 0;
      return nextRule;
    } else {
      // put the rule back on the bottom of the stack
      this.rules.unshift(nextRule);
      // check if we're run through all rules
      if (this.rulesChecked === this.rules.length) return null;
      // otherwise, try again
      return this.selectRule();
    }
  }
  /** Return a generated value based on the symbol's rules and current state of the grammar.
   * @param {Boolean} flatten - optionally set the result as the symbol's new value (overwriting any set value)
   * @returns {String} the expanded result
   */
  expand(flatten) {
    const rule = this.selectRule();
    const result = rule ? rule.evaluate(this.grammar) : '';
    if (flatten) this.value = result;
    return result;
  }
  /** Expand the symbol and set the result as its new value
   * @returns {String} the flattened result
   */
  flatten() {
    return this.expand(true);
  }
  /** Reset the flattened state */
  resetValue() {
    this.flattened = false;
    this.flatText = null;
  }
  /** Reset the whole symbol back to its original rules and unflattened state */
  reset() {
    this.setRules(this.initialRules);
    this.resetValue();
  }
};
